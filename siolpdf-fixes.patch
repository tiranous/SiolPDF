--- a/src/background/background.js
+++ b/src/background/background.js
@@ -89,6 +89,31 @@
     });
 
     console.log('Context menus created successfully');
+
+// Per-tab banner dismiss state
+const __siolpdf_dismissedTabs = new Set();
+
+chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
+  if (msg && msg.type === 'DISMISS_BANNER' && sender.tab && sender.tab.id != null) {
+    __siolpdf_dismissedTabs.add(sender.tab.id);
+    chrome.storage.session.set({ ['siolpdf_dismissed_' + sender.tab.id]: true });
+    sendResponse && sendResponse({ ok: true });
+    return true;
+  }
+  if (msg && msg.type === 'IS_DISMISSED' && sender.tab && sender.tab.id != null) {
+    const key = 'siolpdf_dismissed_' + sender.tab.id;
+    chrome.storage.session.get(key).then(v => {
+      const dismissed = !!(v && v[key]) || __siolpdf_dismissedTabs.has(sender.tab.id);
+      sendResponse && sendResponse({ dismissed });
+    });
+    return true; // async
+  }
+});
+chrome.tabs.onRemoved.addListener((tabId) => {
+  __siolpdf_dismissedTabs.delete(tabId);
+  chrome.storage.session.remove('siolpdf_dismissed_' + tabId);
+});
+
   });
 }
 
@@ -133,7 +158,7 @@
     const editorUrl = chrome.runtime.getURL('src/ui/main/main.html');
 
     // Check if editor is already open
-    const tabs = await chrome.tabs.query({ url: editorUrl });
+    const tabs = await chrome.tabs.query({ url: editorUrl + '*' });
 
     if (tabs.length > 0) {
       // Focus existing editor and send PDF URL
@@ -167,7 +192,7 @@
   setTimeout(async () => {
     try {
       const editorUrl = chrome.runtime.getURL('src/ui/main/main.html');
-      const tabs = await chrome.tabs.query({ url: editorUrl });
+      const tabs = await chrome.tabs.query({ url: editorUrl + '*' });
 
       if (tabs.length > 0) {
         chrome.tabs.sendMessage(tabs[0].id, {
@@ -189,7 +214,7 @@
   setTimeout(async () => {
     try {
       const editorUrl = chrome.runtime.getURL('src/ui/main/main.html');
-      const tabs = await chrome.tabs.query({ url: editorUrl });
+      const tabs = await chrome.tabs.query({ url: editorUrl + '*' });
 
       if (tabs.length > 0) {
         chrome.tabs.sendMessage(tabs[0].id, {
--- a/src/workers/pdf-worker.js
+++ b/src/workers/pdf-worker.js
@@ -6,7 +6,7 @@
 // Import pdf-lib for PDF manipulation (when available)
 try {
   // Dynamic import for when library is available
-  importScripts('../../lib/pdf-lib.min.js');
+  importScripts(chrome.runtime.getURL('src/lib/pdf-lib.min.js'));
 } catch (error) {
   console.warn('PDF-lib not available - using mock implementation');
 }
@@ -35,6 +35,13 @@
         break;
 
       case 'removeCamScanner':
+        result = await removeCamScannerElements(buffer);
+        break;
+
+      case 'removeWatermarkAggressive':
+        result = await aggressiveRemoveWatermarks(buffer);
+        break;
+
         result = await removeCamScannerElements(buffer);
         break;
 
@@ -356,4 +363,71 @@
   }
 }
 
+
+// Aggressive watermark removal: removes Artifact /Watermark blocks, suspicious XObjects and watermark text
+async function aggressiveRemoveWatermarks(pdfBuffer) {
+  if (typeof PDFLib === 'undefined') return pdfBuffer;
+  const { PDFDocument, PDFName, PDFArray } = PDFLib;
+  const pdfDoc = await PDFDocument.load(pdfBuffer, { ignoreEncryption: true });
+  const ctx = pdfDoc.context;
+  const enc = new TextEncoder();
+  const dec = new TextDecoder('latin1');
+
+  function toArray(obj) {
+    if (!obj) return PDFArray.withContext(ctx);
+    if (obj instanceof PDFArray) return obj;
+    const arr = PDFArray.withContext(ctx);
+    arr.push(obj);
+    return arr;
+  }
+
+  for (const page of pdfDoc.getPages()) {
+    const contents = toArray(page.node.get(PDFName.of('Contents')));
+
+    for (let i = 0; i < contents.size(); i++) {
+      const ref = contents.get(i);
+      const stream = ctx.lookup(ref);
+
+      let src = '';
+      try {
+        src = dec.decode(stream.decode ? stream.decode() : (stream.contents || new Uint8Array()));
+      } catch {}
+
+      // 1) Remove Artifact Watermark marked-content blocks
+      src = src.replace(/\/Artifact\s+<<[^>]*\/Subtype\s*\/Watermark[^>]*>>\s*BDC[\s\S]*?EMC/g, '');
+
+      // 2) Remove suspicious XObject drawings
+      src = src.replace(/\/(WM|WATERMARK|CS|CAMSCN|CSLOGO|Wmk\d+)\s+Do/g, '');
+
+      // 3) Remove text operations that contain watermark phrases
+      const WMPAT = /(CamScanner|Scanned\s+with\s+CamScanner|Watermark|Scanned\s+by|Generated\s+by|Sample|Demo)/i;
+      src = src.replace(/\((?:\\\)|\\\(|[^)])*\)\s*Tj/g, m => WMPAT.test(m) ? '' : m);
+      src = src.replace(/\[(?:[^\]]*)\]\s*TJ/g, m => WMPAT.test(m) ? '' : m);
+      src = src.replace(/BT[\s\S]{0,800}?ET/g, m => WMPAT.test(m) ? '' : m);
+
+      const newStream = ctx.flateStream(enc.encode(src));
+      const newRef = ctx.register(newStream);
+      contents.set(i, newRef);
+    }
+
+    page.node.set(PDFName.of('Contents'), contents);
+    page.node.set(PDFName.of('Annots'), PDFArray.withContext(ctx));
+  }
+
+  for (const page of pdfDoc.getPages()) {
+    const res = page.node.get(PDFName.of('Resources'));
+    if (!res) continue;
+    const xobj = res.get(PDFName.of('XObject'));
+    if (!xobj || !xobj.keys) continue;
+    ['WM','WATERMARK','CS','CAMSCN','CSLOGO'].forEach(name => {
+      const k = PDFName.of(name);
+      try { if (xobj.has && xobj.has(k)) xobj.delete(k); } catch {}
+    });
+  }
+
+  try { pdfDoc.setTitle(''); pdfDoc.setAuthor(''); pdfDoc.setCreator(''); pdfDoc.setProducer(''); } catch {}
+
+  return await pdfDoc.save();
+}
+
 console.log('PDF Worker initialized (MV3-compatible)');
--- a/src/ui/main/main.js
+++ b/src/ui/main/main.js
@@ -81,13 +81,13 @@
       // Initialize PDF processing worker
       this.worker = new Worker(
         chrome.runtime.getURL("src/workers/pdf-worker.js"), 
-        { type: "module" }
+        { type: "classic" }
       );
 
       // Initialize merge worker
       this.mergeWorker = new Worker(
         chrome.runtime.getURL("src/workers/merge-worker.js"), 
-        { type: "module" }
+        { type: "classic" }
       );
 
       this.worker.addEventListener('message', this.handleWorkerMessage.bind(this));
